% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/as-tensor.R
\name{as_tensor}
\alias{as_tensor}
\alias{as_tensor.default}
\alias{as_tensor.torch_tensor}
\alias{as_tensor.data.frame}
\alias{as_tensor.ts}
\title{Convert an object to tensor}
\usage{
as_tensor(
  data,
  ...,
  dtype = NULL,
  device = NULL,
  requires_grad = FALSE,
  pin_memory = FALSE
)

\method{as_tensor}{default}(
  data,
  dtype = NULL,
  device = NULL,
  requires_grad = FALSE,
  pin_memory = FALSE
)

\method{as_tensor}{torch_tensor}(data, ..., dtype = NULL, device = NULL, requires_grad = FALSE)

\method{as_tensor}{data.frame}(
  data,
  ...,
  dtype = NULL,
  device = NULL,
  requires_grad = FALSE,
  pin_memory = FALSE
)

\method{as_tensor}{ts}(
  data,
  by = NULL,
  dtype = NULL,
  device = NULL,
  requires_grad = FALSE,
  pin_memory = FALSE
)
}
\arguments{
\item{data}{A data.frame-like object, \code{array}, \code{ts} or \code{torch_tensor}}

\item{...}{Column names to reshape the data.frame-like object into a n-dimensional tensor}

\item{dtype}{A torch_dtype instance}

\item{device}{A device created with torch_device()}

\item{requires_grad}{If autograd should record operations on the returned tensor.}

\item{pin_memory}{If set, returned tensor would be allocated in the pinned memory.}

\item{by}{For \code{ts} objects only. The length of time series to reshape the time series into tensor.}
}
\value{
An object of \code{torch_tensor} class
}
\description{
The function converts an an object to \code{torch_tensor} instance.
Possible arguments differ a little bit depending on the input object class.
\itemize{
\item \code{torch_tensor}

Returns identical \code{torch_tensor}, but changes dtype or device if specified.
Three dots arguments are ignored for now.
\item \code{data.frame}

If no column names are specified (as "three dots"), the function
simply transforms the input data to \code{matrix} and then to \code{torch_tensor}.

The second scenario assumes that we need a \code{torch_tensor},
which has more than two dimensions and some columns contains
indicators, how this wrapping should be performed.

It's especially useful when transforming a data.frame containing
multiple (and, possibly, multivariate) time series.
When passing optional column names, function:
\itemize{
\item arranges a data.frame by the given columns
\item removes these columns from the data.frame
\item creates a n-dimensional tensor with the following shape
(n_distinct(column_name_1), n_distinct(column_name_2), ..., number of other columns)
}
\item \code{ts}

If \code{by} is not specified, it returns a tensor of shape \verb{(1, length(object), 1)}.
If we use any \code{by}, the output shape is \verb{(length(data)/by, by, 1)}
}
}
\examples{
library(dplyr, warn.conflicts = FALSE)
library(torchts)

# Simple data.frame-to-torch_tensor transformation
as_tensor(head(mtcars))

# Transformation with column-wise data wrapping
weather_tensor <-
  weather_pl \%>\%
  select(-rr_type) \%>\%
  as_tensor(station, date)

dim(weather_tensor)

# ts class - default
air_passengers <- as_tensor(AirPassengers)
class(air_passengers)
dim(air_passengers)

# ts class using data frequency
air_passengers <-
  AirPassengers \%>\%
  as_tensor(frequency(.))

class(air_passengers)
dim(air_passengers)

# ts class using arbitrary frequency
air_passengers <-
 as_tensor(AirPassengers, 6)

class(air_passengers)
dim(air_passengers)

}
